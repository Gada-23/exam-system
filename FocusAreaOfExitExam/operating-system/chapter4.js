// ===============================
// FOCUS AREA: OPERATING SYSTEM - CHAPTER 4
// Memory Management
// Based on Ministry of Education Blueprint
// ===============================

window.focusAreaOSChapter4 = {
    title: "Chapter 4: Memory Management",
    
    // Blueprint alignment: 1 question (Understand)
    blueprint: {
        totalQuestions: 1,
        cognitiveLevels: {
            understand: 1
        },
        topics: [
            "Memory management concepts",
            "Contiguous memory allocation",
            "Paging",
            "Segmentation",
            "Virtual memory"
        ]
    },

    learningObjectives: [
        "Understand the goals of memory management",
        "Explain contiguous memory allocation techniques",
        "Describe paging and segmentation",
        "Understand virtual memory concepts",
        "Differentiate between logical and physical addresses"
    ],

    sections: [
        {
            title: "4.1 Introduction to Memory Management",
            content: `
                <h4>Why Memory Management?</h4>
                <p>Memory management is a critical function of the operating system. It manages the computer's primary memory (RAM), allocating memory to processes, tracking used and free memory, and protecting memory spaces.</p>
                
                <h4>Goals of Memory Management</h4>
                <ul>
                    <li><strong>Efficient utilization:</strong> Make best use of limited memory</li>
                    <li><strong>Protection:</strong> Prevent processes from accessing each other's memory</li>
                    <li><strong>Sharing:</strong> Allow controlled sharing of memory when needed</li>
                    <li><strong>Logical organization:</strong> Provide logical view of memory to programs</li>
                    <li><strong>Physical organization:</strong> Map logical memory to physical memory</li>
                </ul>
                
                <h4>Logical vs Physical Addresses</h4>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Address Type</th>
                        <th style="padding:10px; border:1px solid #ddd;">Description</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Logical Address</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Address generated by the CPU (virtual address). It is the address seen by the process.</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Physical Address</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Actual address in physical memory (RAM).</td>
                    </tr>
                </table>
                
                <h4>Memory Management Unit (MMU)</h4>
                <p>The MMU is a hardware device that maps logical addresses to physical addresses at runtime.</p>
                
                <div class="key-points-box" style="background:#e8f0f5; padding:15px; border-radius:8px; margin:15px 0;">
                    <p><strong>üîë Important:</strong> The <strong>Memory Management Unit (MMU)</strong> is the hardware device that maps physical address to logical address.</p>
                </div>
                
                <h4>Hardware device that maps physical address to logical address is</h4>
                <p><strong>MMU (Memory Management Unit)</strong> is the hardware device that performs this mapping.</p>
                
                <h4>Logical memory is broken into blocks of the same size called</h4>
                <p><strong>Pages</strong> (in paging) or <strong>Segments</strong> (in segmentation). In paging, logical memory is divided into fixed-size blocks called pages.</p>
            `,
            keyPoints: [
                "Memory management allocates and protects memory",
                "Logical address = CPU-generated, Physical address = actual RAM address",
                "MMU maps logical to physical addresses",
                "MMU is the hardware device that maps physical address to logical address",
                "Pages are fixed-size blocks in paging"
            ]
        },

        {
            title: "4.2 Contiguous Memory Allocation",
            content: `
                <h4>Contiguous Allocation</h4>
                <p>In contiguous memory allocation, each process is allocated a single contiguous block of memory.</p>
                
                <h4>Memory Partitions</h4>
                <ul>
                    <li><strong>Fixed Partitioning:</strong> Memory divided into fixed-size partitions</li>
                    <li><strong>Dynamic Partitioning:</strong> Partitions created dynamically to fit process sizes</li>
                </ul>
                
                <h4>Allocation Algorithms</h4>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Algorithm</th>
                        <th style="padding:10px; border:1px solid #ddd;">Description</th>
                        <th style="padding:10px; border:1px solid #ddd;">Advantages</th>
                        <th style="padding:10px; border:1px solid #ddd;">Disadvantages</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>First Fit</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Allocate the first hole that is big enough</td>
                        <td style="padding:8px; border:1px solid #ddd;">Fast, simple</td>
                        <td style="padding:8px; border:1px solid #ddd;">Can fragment memory</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Best Fit</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Allocate the smallest hole that is big enough</td>
                        <td style="padding:8px; border:1px solid #ddd;">Minimizes wasted space</td>
                        <td style="padding:8px; border:1px solid #ddd;">Leaves very small holes, slow</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Worst Fit</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Allocate the largest hole</td>
                        <td style="padding:8px; border:1px solid #ddd;">Leaves larger holes</td>
                        <td style="padding:8px; border:1px solid #ddd;">Poor memory utilization</td>
                    </tr>
                </table>
                
                <h4>In terms of speed and storage utilization,</h4>
                <ul>
                    <li><strong>First fit algorithm</strong> is generally better in terms of speed</li>
                    <li><strong>Best fit algorithm</strong> is better in terms of storage utilization (minimizes waste)</li>
                    <li><strong>Worst fit</strong> is generally poorer in both aspects</li>
                </ul>
                
                <h4>Fragmentation</h4>
                <ul>
                    <li><strong>External fragmentation:</strong> Free memory exists but is not contiguous enough to satisfy a request</li>
                    <li><strong>Internal fragmentation:</strong> Allocated memory may have some unused space inside the partition</li>
                </ul>
                
                <p><strong>Compaction:</strong> Technique to reduce external fragmentation by moving allocated processes to create larger contiguous free space.</p>
            `,
            keyPoints: [
                "Contiguous allocation: each process in one contiguous block",
                "First fit: first hole that fits",
                "Best fit: smallest hole that fits (best utilization)",
                "Worst fit: largest hole",
                "External fragmentation: non-contiguous free space",
                "Internal fragmentation: wasted space within allocated block"
            ]
        },

        {
            title: "4.3 Paging",
            content: `
                <h4>What is Paging?</h4>
                <p>Paging is a memory management scheme that eliminates the need for contiguous allocation. Physical memory is divided into fixed-sized blocks called <strong>frames</strong>. Logical memory is divided into blocks of the same size called <strong>pages</strong>.</p>
                
                <div style="background-color:#e8f0f5; padding:20px; border-radius:8px; margin:20px 0;">
                    <p style="font-size:18px; font-weight:bold; color:#2772a0; text-align:center;">PAGING</p>
                    <pre style="text-align:center;">
Logical Memory          Physical Memory
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇPage 0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇFrame ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ           ‚îÇ 2    ‚îÇ
‚îÇPage 1 ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                ‚îÇFrame ‚îÇ
‚îÇPage 2 ‚îÇ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ 0    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ           ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇPage 3 ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇFrame ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ 1    ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    </pre>
                </div>
                
                <h4>Logical memory is broken into blocks of the same size called</h4>
                <p><strong>Pages.</strong></p>
                
                <h4>Physical memory is broken into blocks of the same size called</h4>
                <p><strong>Frames.</strong></p>
                
                <h4>Page Table</h4>
                <p>A page table is used to map logical pages to physical frames. Each process has its own page table.</p>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Page Number</th>
                        <th style="padding:10px; border:1px solid #ddd;">Frame Number</th>
                    </tr>
                    <tr><td>0</td><td>2</td></tr>
                    <tr><td>1</td><td>0</td></tr>
                    <tr><td>2</td><td>1</td></tr>
                    <tr><td>3</td><td>3</td></tr>
                </table>
                
                <h4>Address Translation</h4>
                <p>A logical address is divided into:</p>
                <ul>
                    <li><strong>Page number (p):</strong> Index into page table</li>
                    <li><strong>Page offset (d):</strong> Displacement within the page</li>
                </ul>
                
                <pre style="background:#f4f4f4; padding:10px; border-radius:5px;">
Logical Address = (p, d)
Physical Address = (frame number from page table[p], d)
                </pre>
                
                <h4>Advantages of Paging</h4>
                <ul>
                    <li>No external fragmentation</li>
                    <li>Efficient use of memory</li>
                    <li>Easy to swap</li>
                </ul>
                
                <h4>Disadvantages</h4>
                <ul>
                    <li>Internal fragmentation (last page may be partially filled)</li>
                    <li>Page table overhead</li>
                </ul>
                
                <h4>Hardware device that maps physical address to logical address is</h4>
                <p>The <strong>MMU (Memory Management Unit)</strong> with the help of the page table performs this mapping.</p>
            `,
            keyPoints: [
                "Paging: logical memory = pages, physical memory = frames",
                "Page table maps pages to frames",
                "No external fragmentation",
                "Internal fragmentation possible in last page",
                "Address = (page number, offset)"
            ]
        },

        {
            title: "4.4 Segmentation",
            content: `
                <h4>What is Segmentation?</h4>
                <p>Segmentation is a memory management scheme that supports the user's view of memory. A program is divided into segments (code, data, stack, etc.), each of which is a logical unit.</p>
                
                <h4>Segmentation vs Paging</h4>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Aspect</th>
                        <th style="padding:10px; border:1px solid #ddd;">Paging</th>
                        <th style="padding:10px; border:1px solid #ddd;">Segmentation</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">Division</td>
                        <td style="padding:8px; border:1px solid #ddd;">Fixed-size pages</td>
                        <td style="padding:8px; border:1px solid #ddd;">Variable-sized segments</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">User view</td>
                        <td style="padding:8px; border:1px solid #ddd;">Transparent to user</td>
                        <td style="padding:8px; border:1px solid #ddd;">Visible to user</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">Fragmentation</td>
                        <td style="padding:8px; border:1px solid #ddd;">Internal</td>
                        <td style="padding:8px; border:1px solid #ddd;">External</td>
                    </tr>
                </table>
                
                <h4>Segment Table</h4>
                <p>Each segment has:</p>
                <ul>
                    <li><strong>Base:</strong> Starting physical address</li>
                    <li><strong>Limit:</strong> Length of the segment</li>
                </ul>
                
                <h4>Address Translation</h4>
                <p>A logical address in segmentation is (segment number, offset). The offset must be less than the segment limit.</p>
                
                <h4>Advantages of Segmentation</h4>
                <ul>
                    <li>Matches user's view of memory</li>
                    <li>Supports sharing and protection at segment level</li>
                    <li>No internal fragmentation</li>
                </ul>
                
                <h4>Disadvantages</h4>
                <ul>
                    <li>External fragmentation</li>
                    <li>Variable-size segments make allocation complex</li>
                </ul>
            `,
            keyPoints: [
                "Segmentation: variable-sized logical units",
                "Segment table has base and limit",
                "No internal fragmentation",
                "External fragmentation possible",
                "Matches user's view (code, data, stack)"
            ]
        },

        {
            title: "4.5 Virtual Memory",
            content: `
                <h4>What is Virtual Memory?</h4>
                <p>Virtual memory is a technique that allows the execution of processes that are not completely in memory. It separates the logical memory (virtual addresses) from physical memory, allowing programs to be larger than physical memory.</p>
                
                <h4>Key Concepts</h4>
                <ul>
                    <li><strong>Virtual address space:</strong> The logical view of a process's memory</li>
                    <li><strong>Physical memory:</strong> Actual RAM available</li>
                    <li><strong>Demand paging:</strong> Only load pages when they are needed</li>
                    <li><strong>Page fault:</strong> When a referenced page is not in memory</li>
                </ul>
                
                <h4>Demand Paging</h4>
                <p>With demand paging, pages are loaded only when they are referenced. This reduces I/O and memory usage.</p>
                
                <h4>When does page fault occur?</h4>
                <p>A <strong>page fault</strong> occurs when a program attempts to access a memory page that is not currently loaded in physical memory.</p>
                
                <div class="key-points-box" style="background:#e8f0f5; padding:15px; border-radius:8px; margin:15px 0;">
                    <p><strong>üîë Important:</strong> A <strong>page fault</strong> occurs when the page is not present in memory.</p>
                </div>
                
                <h4>Page Fault Handling</h4>
                <ol>
                    <li>Hardware traps to OS</li>
                    <li>OS checks if the reference was valid</li>
                    <li>OS finds a free frame</li>
                    <li>OS schedules disk operation to read the page into memory</li>
                    <li>Page table is updated</li>
                    <li>Instruction is restarted</li>
                </ol>
                
                <h4>Page Replacement</h4>
                <p>When no free frames are available, the OS must replace an existing page. Page replacement algorithms include:</p>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Algorithm</th>
                        <th style="padding:10px; border:1px solid #ddd;">Description</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>FIFO (First-In-First-Out)</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Replace the oldest page</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>LRU (Least Recently Used)</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Replace the page not used for the longest time</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Optimal</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Replace the page that will not be used for the longest time (theoretical, for comparison)</td>
                    </tr>
                </table>
                
                <h4>Thrashing</h4>
                <p>Thrashing occurs when a process spends more time paging than executing. It happens when there are too many processes in memory, causing constant page faults.</p>
            `,
            keyPoints: [
                "Virtual memory = execute programs larger than physical memory",
                "Demand paging = load pages only when needed",
                "Page fault = page not in memory",
                "Page replacement algorithms choose victim pages",
                "Thrashing = excessive paging, low CPU utilization"
            ]
        },

        {
            title: "4.6 Page Replacement Algorithms",
            content: `
                <h4>Page Replacement Algorithms Comparison</h4>
                
                <h4>FIFO (First-In-First-Out)</h4>
                <p>The oldest page (brought in earliest) is replaced.</p>
                <p><strong>Advantage:</strong> Simple to implement</p>
                <p><strong>Disadvantage:</strong> May suffer from Belady's anomaly (more frames can cause more page faults)</p>
                
                <h4>Optimal Page Replacement</h4>
                <p>Replace the page that will not be used for the longest time in the future.</p>
                <p><strong>Advantage:</strong> Lowest page fault rate (optimal)</p>
                <p><strong>Disadvantage:</strong> Impossible to implement (needs future knowledge) - used as benchmark</p>
                
                <h4>LRU (Least Recently Used)</h4>
                <p>Replace the page that has not been used for the longest time.</p>
                <p><strong>Advantage:</strong> Good performance, approximates optimal</p>
                <p><strong>Disadvantage:</strong> Hardware support needed, more complex</p>
                
                <h4>Example</h4>
                <p>Reference string: 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2 with 3 frames</p>
                
                <p><strong>FIFO:</strong> 15 page faults</p>
                <p><strong>LRU:</strong> 12 page faults</p>
                <p><strong>Optimal:</strong> 9 page faults</p>
                
                <h4>Belady's Anomaly</h4>
                <p>In FIFO, increasing the number of frames can sometimes increase the number of page faults. This is called Belady's anomaly. Optimal and LRU do not suffer from this anomaly.</p>
            `,
            keyPoints: [
                "FIFO: oldest page first, simple but may have Belady's anomaly",
                "Optimal: replace page used farthest in future (benchmark)",
                "LRU: replace least recently used, good performance",
                "LRU approximates optimal",
                "FIFO can have Belady's anomaly"
            ]
        },

        {
            title: "4.7 Swapping",
            content: `
                <h4>What is Swapping?</h4>
                <p>Swapping is a memory management technique where processes are moved temporarily from main memory to secondary storage (disk) and then brought back to continue execution.</p>
                
                <h4>What does the term "swapping" refer to in the context of memory management?</h4>
                <p><strong>Moving entire processes between main memory and secondary storage.</strong></p>
                
                <h4>Swapping Process</h4>
                <ul>
                    <li>When a process is swapped out, its entire memory image is saved to disk</li>
                    <li>The freed memory can be allocated to other processes</li>
                    <li>When the process is ready to run again, it is swapped back into memory</li>
                </ul>
                
                <h4>Swapping vs Paging</h4>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Aspect</th>
                        <th style="padding:10px; border:1px solid #ddd;">Swapping</th>
                        <th style="padding:10px; border:1px solid #ddd;">Paging</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">Unit</td>
                        <td style="padding:8px; border:1px solid #ddd;">Entire process</td>
                        <td style="padding:8px; border:1px solid #ddd;">Individual pages</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">Overhead</td>
                        <td style="padding:8px; border:1px solid #ddd;">High (entire process)</td>
                        <td style="padding:8px; border:1px solid #ddd;">Lower (only needed pages)</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;">Used in</td>
                        <td style="padding:8px; border:1px solid #ddd;">Older systems</td>
                        <td style="padding:8px; border:1px solid #ddd;">Modern virtual memory systems</td>
                    </tr>
                </table>
                
                <h4>Swapping in Modern Systems</h4>
                <p>Modern systems rarely swap entire processes due to the overhead. Instead, they use paging with page-level swapping.</p>
            `,
            keyPoints: [
                "Swapping = moving entire processes between memory and disk",
                "Used to free memory for other processes",
                "High overhead (whole process moved)",
                "Modern systems use paging instead of swapping"
            ]
        },

        {
            title: "4.8 Memory Protection",
            content: `
                <h4>Protecting Memory</h4>
                <p>Memory protection ensures that processes cannot access memory outside their allocated space, providing isolation and security.</p>
                
                <h4>Protection Mechanisms</h4>
                
                <table style="width:100%; border-collapse: collapse; margin:15px 0;">
                    <tr style="background-color:#2772a0; color:white;">
                        <th style="padding:10px; border:1px solid #ddd;">Mechanism</th>
                        <th style="padding:10px; border:1px solid #ddd;">Description</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Base and Limit Registers</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Define the legal range of addresses for a process</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Protection Bits</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">In page/segment tables, indicate read/write/execute permissions</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #ddd;"><strong>Valid/Invalid Bits</strong></td>
                        <td style="padding:8px; border:1px solid #ddd;">Indicate whether a page is in the process's address space</td>
                    </tr>
                </table>
                
                <h4>Hardware Support</h4>
                <ul>
                    <li>MMU checks every memory access against protection information</li>
                    <li>If violation occurs, hardware traps to OS</li>
                </ul>
            `,
            keyPoints: [
                "Memory protection prevents unauthorized access",
                "Base/limit registers define legal range",
                "Protection bits control permissions",
                "Valid/invalid bits identify accessible pages"
            ]
        }
    ],

    summary: `
        <h3>Chapter 4 Summary - Key Takeaways:</h3>
        <ul>
            <li><strong>Memory Management Unit (MMU):</strong> Hardware that maps physical to logical addresses</li>
            <li><strong>Logical vs Physical:</strong> Logical = CPU-generated, Physical = actual RAM</li>
            <li><strong>Contiguous allocation:</strong> First fit (fast), Best fit (efficient), Worst fit</li>
            <li><strong>Paging:</strong> Logical memory = pages, Physical memory = frames</li>
            <li><strong>Page table:</strong> Maps pages to frames</li>
            <li><strong>Virtual memory:</strong> Execute programs larger than physical memory</li>
            <li><strong>Page fault:</strong> Occurs when page is not in memory</li>
            <li><strong>Page replacement:</strong> FIFO, LRU, Optimal</li>
            <li><strong>Swapping:</strong> Moving entire processes between memory and disk</li>
            <li><strong>Logical memory is broken into blocks of the same size called pages</strong></li>
            <li><strong>MMU is the hardware device that maps physical address to logical address</strong></li>
            <li><strong>Page fault occurs when the page does not present in memory</strong></li>
        </ul>
    `,

    reviewQuestions: [
        {
            question: "What is the purpose of the Memory Management Unit (MMU)?",
            answer: "The MMU maps logical addresses to physical addresses during runtime."
        },
        {
            question: "What is the difference between logical and physical addresses?",
            answer: "Logical address is generated by CPU; physical address is actual location in RAM."
        },
        {
            question: "What are pages and frames in paging?",
            answer: "Pages are fixed-size blocks of logical memory; frames are same-sized blocks of physical memory."
        },
        {
            question: "When does a page fault occur?",
            answer: "A page fault occurs when a program accesses a page that is not currently in physical memory."
        },
        {
            question: "What hardware device maps physical address to logical address?",
            answer: "The Memory Management Unit (MMU)."
        },
        {
            question: "What does the term 'swapping' refer to in memory management?",
            answer: "Moving entire processes between main memory and secondary storage."
        }
    ],

    quickTips: [
        "MMU maps logical to physical addresses",
        "Pages = logical blocks, Frames = physical blocks",
        "Page fault = page not in memory",
        "First fit = fast, Best fit = efficient",
        "LRU approximates optimal",
        "FIFO may have Belady's anomaly"
    ],

    commonMistakes: [
        "‚ùå Confusing pages and frames - pages are logical, frames are physical",
        "‚ùå Thinking MMU maps physical to logical - it maps logical to physical",
        "‚ùå Forgetting that page fault means page not in memory",
        "‚ùå Mixing up paging and segmentation",
        "‚ùå Not understanding that swapping moves entire processes"
    ],

    examPreparation: `
        <h3>Blueprint Alignment for Chapter 4:</h3>
        <p>According to the Ministry of Education blueprint, this chapter will have <strong>1 question</strong> at the <strong>Understand</strong> level.</p>
        
        <h4>Focus on These Topics:</h4>
        <ol>
            <li><strong>MMU:</strong> Hardware that maps physical to logical addresses</li>
            <li><strong>Page fault:</strong> Occurs when page not in memory</li>
            <li><strong>Paging:</strong> Logical memory divided into pages</li>
            <li><strong>Swapping:</strong> Moving processes between memory and disk</li>
        </ol>
        
        <h4>What "Understand" Means:</h4>
        <p>You need to be able to explain memory management concepts, differentiate between paging and segmentation, and understand virtual memory basics.</p>
        
        <h4>Practice Questions:</h4>
        <ul>
            <li>What is the role of the Memory Management Unit?</li>
            <li>Explain the concept of paging and how it eliminates external fragmentation.</li>
            <li>What is a page fault and how is it handled?</li>
            <li>What does swapping mean in memory management?</li>
        </ul>
    `
};